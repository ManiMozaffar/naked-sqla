{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Naked SQLAlchemy","text":"<p>Naked SQLAlchemy is a simple and efficient layer on top of SQLAlchemy Core, designed to make database access faster and easier by focusing on query execution and result mapping to data classes.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Dataclass Mapping: Automatically map query results directly to Python dataclasses, eliminating the need for manual mapping.</li> <li>Stateless Session Management: Manage database sessions and transactions without the overhead of ORM state tracking or identity mapping.</li> <li>Support for Database Views: Easily treat database views like tables, enabling queries without the limitations imposed by traditional ORMs.</li> <li>Minimal Learning Curve: Minimal learning curve for developers familiar with SQL. Most complexity and most of SQLAlchemy documentation is because of SQLAlchemy ORM.</li> </ul> <p>Naked SQLAlchemy is ideal for developers who want the power and flexibility of SQLAlchemy Core but without the unnecessary complexity and overheard of SQLAlchemy ORM. Whether you're dealing with database tables or views, this library provides a clean, efficient interface to work with your data, in closest possible</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install naked-sqlalchemy\n</code></pre>"},{"location":"#attention","title":"Attention","text":"<p>This library is not compatiable with SQLAlchemy ORM, and the goal is to provide an Engine with data mapper capabilities. If you are looking for an ORM, this library is not for you.</p> <p>Any features such as relationship, lazy loading, identity map, etc. are not supported and will not be supported in the future.</p>"},{"location":"api/async-session/","title":"Async Session","text":"<p>This section is about the Session class. This class is a simple wrapper around the <code>Connection</code> object. Session main purpose is to execute queries and return the result, as mapped to ORM objects.</p> <p>By design, to ensure consistency and simplicity, Session are always within a transaction. So you should always commit or rollback the transaction after you are done with the session.</p> <p>Session Factory is a factory for creating sessions. You should use this factory to create a new session every time you need to start a new transaction.</p>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSessionFactory","title":"AsyncSessionFactory","text":"<pre><code>AsyncSessionFactory(engine: AsyncEngine, *, auto_commit: bool = True)\n</code></pre> <p>A factory for creating async sessions.</p> <p>Usually you should use this factory with Engine, and then use the <code>begin</code> method to create a session every time</p> If you are using FastAPI, always use a single instance of this factory as a dependency. <p>If you are using FastAPI, you should create a single instance of this factory and use it as a dependency. So you don't initiate a new AsyncSessionFactory every time you create a session. So something like this:</p> <pre><code>from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom naked_sqla.om.asession import AsyncSessionFactory\n\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\ndb = AsyncSessionFactory(engine)\nasync def get_session_factory():\n    return db\n</code></pre> <p>And then call .begin() method in your route functions whenever you need to start a new transaction.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>AsyncEngine</code> <p>The engine object that will be used for creating connections.</p> required <code>auto_commit</code> <code>bool</code> <p>If True, the session will automatically commit the transaction after the block ends.     If any exception occurs, it will rollback the transaction. If False, you have to manually commit or rollback the transaction. If you don't commit or rollback the transaction, it will be rolled back automatically.</p> <code>True</code> Example <pre><code>from sqlalchemy.ext.asyncio import create_async_engine\nfrom naked_sqla.om.asession import AsyncSessionFactory\n\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\ndb = AsyncSessionFactory(engine)\n</code></pre> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>def __init__(self, engine: AsyncEngine, *, auto_commit: bool = True):\n    self.engine = engine\n    self.auto_commit = auto_commit\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSessionFactory.begin","title":"begin  <code>async</code>","text":"<pre><code>begin()\n</code></pre> <p>Create a new session, commits the transaction if auto_commit is True. Returns a context manager that yields a Session object.</p> <p>You can use this context manager with the <code>with</code> statement to access session.</p> Example <pre><code>from sqlalchemy.ext.asyncio import create_async_engine\nfrom naked_sqla.om.asession import AsyncSessionFactory\n\nengine = create_engine(\"sqlite+aiosqlite:///:memory:\")\ndb = AsyncSessionFactory(engine)\n\nasync def main():\n    async with db.begin() as session:\n        query = ...\n        await session.execute(query)\n</code></pre> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>@asynccontextmanager\nasync def begin(self):\n    \"\"\"\n    Create a new session, commits the transaction if auto_commit is True.\n    Returns a context manager that yields a Session object.\n\n    You can use this context manager with the `with` statement to access session.\n\n    Example:\n        ```python\n        from sqlalchemy.ext.asyncio import create_async_engine\n        from naked_sqla.om.asession import AsyncSessionFactory\n\n        engine = create_engine(\"sqlite+aiosqlite:///:memory:\")\n        db = AsyncSessionFactory(engine)\n\n        async def main():\n            async with db.begin() as session:\n                query = ...\n                await session.execute(query)\n        ```\n    \"\"\"\n\n    async with self.engine.begin() as conn:\n        try:\n            yield AsyncSession(conn)\n            if self.auto_commit:\n                await conn.commit()\n            else:\n                if conn.in_transaction():\n                    await conn.rollback()\n\n        except Exception as err:\n            if self.auto_commit:\n                await conn.rollback()\n            raise err\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSession","title":"AsyncSession","text":"<pre><code>AsyncSession(conn: AsyncConnection)\n</code></pre> <p>AsyncSession is the async version of the Session object.</p> <p>Session is an object that represents a single transaction to the database. You can execute query statements and commit or rollback the transaction.</p> <p>Session is a simple wrapper around Connection object. The difference between Session and Connection is that Session would map     your query results to ORM objects.</p> Session is completely incompatible with sqlalchemy ORM Session. <p>Session is a simple wrapper around the Connection object.</p> <p>Please avoid using Session if you are depending on SQLAlchemy ORM. Any ORM feature in SQLAlchemy does not work with Session.</p> <p>These features could be:</p> <ul> <li>Tracking ORM objects: methods like <code>add</code>, <code>flush</code>, <code>expunge</code>, etc. Because our Session does not have any ORM object tracking. Which simplifies the implementation and makes it way faster.</li> </ul> <ul> <li>Relationship loading: methods like <code>load</code>, <code>lazyload</code>, etc. Because our Session does not make any implicit query to the database. You have to explicitly write the query. If you want to load related objects, you have to write a query for that and join the tables manually like you do in SQL.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncConnection</code> <p>The connection object that will be used for executing queries.</p> required Example <pre><code>from datetime import datetime\nfrom uuid import uuid4\n\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column\n\nfrom naked_sqla.om.asession import AsyncSessionFactory\n\n\nclass BaseSQL(MappedAsDataclass, DeclarativeBase): ...\n\n\nclass Book(BaseSQL):\n    __tablename__ = \"Events\"\n    created_at: Mapped[datetime]\n    name: Mapped[str]\n    author_name: Mapped[str]\n    id: Mapped[str] = mapped_column(\n        primary_key=True, default_factory=lambda: str(uuid4())\n    )\n\n\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\")\ndb = AsyncSessionFactory(engine)\n\nasync def get_db():\n    return db\n</code></pre> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>def __init__(self, conn: AsyncConnection):\n    self.conn = conn\n    self.state: Literal[\"open\", \"closed\"] = \"open\"\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSession.commit","title":"commit  <code>async</code>","text":"<pre><code>commit()\n</code></pre> <p>Commit the transaction.</p> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>async def commit(self):\n    \"\"\"Commit the transaction.\"\"\"\n    if self.state == \"closed\":\n        raise InvalidSessionState(self.state, \"open\")\n\n    elif self.state == \"open\":\n        await self.conn.commit()\n        self.state = \"closed\"\n    else:\n        assert_never(self.state)\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSession.rollback","title":"rollback  <code>async</code>","text":"<pre><code>rollback()\n</code></pre> <p>Rollback the transaction.</p> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>async def rollback(self):\n    \"\"\"Rollback the transaction.\"\"\"\n    if self.state == \"closed\":\n        raise InvalidSessionState(self.state, \"open\")\n\n    elif self.state == \"open\":\n        await self.conn.rollback()\n        self.state = \"closed\"\n    else:\n        assert_never(self.state)\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSession.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = None, *, execution_options: Optional[_CoreKnownExecutionOptions] = None) -&gt; Result[Any]\n</code></pre> <p>Execute a query statement and return the result.</p> <p>After calling this method, you should call the <code>tuples</code> or <code>scalars</code> method to get the result.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The query statement to execute.</p> required <code>parameters</code> <code>Optional[_CoreAnyExecuteParams]</code> <p>The parameters to pass to the query.</p> <code>None</code> <code>execution_options</code> <code>Optional[_CoreKnownExecutionOptions]</code> <p>The execution options to pass to the query.</p> <code>None</code> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>async def execute(\n    self,\n    statement: Executable,\n    parameters: Optional[_CoreAnyExecuteParams] = None,\n    *,\n    execution_options: Optional[_CoreKnownExecutionOptions] = None,\n) -&gt; Result[Any]:\n    \"\"\"\n    Execute a query statement and return the result.\n\n    After calling this method, you should call the `tuples` or `scalars` method to get the result.\n\n    params:\n        statement:\n            The query statement to execute.\n        parameters:\n            The parameters to pass to the query.\n        execution_options:\n            The execution options to pass to the query.\n    \"\"\"\n\n    if (\n        isinstance(statement, dml.Insert)\n        or isinstance(statement, dml.Update)\n        or isinstance(statement, dml.Delete)\n    ):\n        return await bulk_persistent.orm_execute_statement(\n            self.conn,\n            statement,  # type: ignore\n            parameters=parameters,\n            execution_options=execution_options,\n        )\n\n    elif isinstance(statement, Executable):\n        return await context.orm_execute_statement(\n            self.conn,\n            statement,\n            parameters=parameters,\n            execution_options=execution_options,\n        )\n\n    else:\n        assert_never(statement)\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSession.tuples","title":"tuples  <code>async</code>","text":"<pre><code>tuples(statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = None, *, execution_options: Optional[_CoreKnownExecutionOptions] = None) -&gt; TupleResult[Any]\n</code></pre> <p>Execute a query statement and return the result as tuples.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The query statement to execute.</p> required <code>parameters</code> <code>Optional[_CoreAnyExecuteParams]</code> <p>The parameters to pass to the query.</p> <code>None</code> <code>execution_options</code> <code>Optional[_CoreKnownExecutionOptions]</code> <p>The execution options to pass to the query.</p> <code>None</code> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>async def tuples(\n    self,\n    statement: Executable,\n    parameters: Optional[_CoreAnyExecuteParams] = None,\n    *,\n    execution_options: Optional[_CoreKnownExecutionOptions] = None,\n) -&gt; TupleResult[Any]:\n    \"\"\"\n    Execute a query statement and return the result as tuples.\n\n    params:\n        statement:\n            The query statement to execute.\n        parameters:\n            The parameters to pass to the query.\n        execution_options:\n            The execution options to pass to the query.\n    \"\"\"\n\n    result = (\n        await self.execute(\n            statement, parameters, execution_options=execution_options\n        )\n    ).tuples()\n    return result\n</code></pre>"},{"location":"api/async-session/#naked_sqla.om.asession.AsyncSession.scalars","title":"scalars  <code>async</code>","text":"<pre><code>scalars(statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = None, *, execution_options: Optional[_CoreKnownExecutionOptions] = None) -&gt; ScalarResult[Any]\n</code></pre> <p>Execute a query statement and return the result as scalars.</p> <p>Scalar data types represent single values. They are the simplest forms of data types in programming. If you select two entities (e.x: two columns or two tables), it will return only first entity. Consider this as a shortcut when you are selecting only one entity, so you don't have to access to the first element of the tuple.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The query statement to execute.</p> required <code>parameters</code> <code>Optional[_CoreAnyExecuteParams]</code> <p>The parameters to pass to the query.</p> <code>None</code> <code>execution_options</code> <code>Optional[_CoreKnownExecutionOptions]</code> <p>The execution options to pass to the query</p> <code>None</code> Source code in <code>naked_sqla/om/asession.py</code> <pre><code>async def scalars(\n    self,\n    statement: Executable,\n    parameters: Optional[_CoreAnyExecuteParams] = None,\n    *,\n    execution_options: Optional[_CoreKnownExecutionOptions] = None,\n) -&gt; ScalarResult[Any]:\n    \"\"\"\n    Execute a query statement and return the result as scalars.\n\n    Scalar data types represent single values. They are the simplest forms of data types in programming.\n    If you select two entities (e.x: two columns or two tables), it will return only first entity.\n    Consider this as a shortcut when you are selecting only one entity, so you don't have to access to the first element of the tuple.\n\n    params:\n        statement:\n            The query statement to execute.\n        parameters:\n            The parameters to pass to the query.\n        execution_options:\n            The execution options to pass to the query\n    \"\"\"\n    result = (\n        await self.execute(\n            statement, parameters, execution_options=execution_options\n        )\n    ).scalars()\n    return result\n</code></pre>"},{"location":"api/session/","title":"Session","text":"<p>This section is about the Session class. This class is a simple wrapper around the <code>Connection</code> object. Session main purpose is to execute queries and return the result, as mapped to ORM objects.</p> <p>By design, to ensure consistency and simplicity, Session are always within a transaction. So you should always commit or rollback the transaction after you are done with the session.</p> <p>Session Factory is a factory for creating sessions. You should use this factory to create a new session every time you need to start a new transaction.</p>"},{"location":"api/session/#naked_sqla.om.session.SessionFactory","title":"SessionFactory","text":"<pre><code>SessionFactory(engine: Engine, *, auto_commit: bool = True)\n</code></pre> <p>A factory for creating sync sessions.</p> <p>Usually you should use this factory with Engine, and then use the <code>begin</code> method to create a session every time</p> If you are using FastAPI, always use a single instance of this factory as a dependency. <p>If you are using FastAPI, you should create a single instance of this factory and use it as a dependency. So you don't initiate a new SessionFactory every time you create a session. So something like this:</p> <pre><code>from fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine\nfrom naked_sqla.om.session import SessionFactory\n\nengine = create_engine(\"sqlite:///:memory:\")\ndb = SessionFactory(engine)\ndef get_session_factory():\n    return db\n</code></pre> <p>And then call .begin() method in your route functions whenever you need to start a new transaction.</p> <p>Parameters:</p> Name Type Description Default <code>engine</code> <code>Engine</code> <p>The engine object that will be used for creating connections.</p> required <code>auto_commit</code> <code>bool</code> <p>If True, the session will automatically commit the transaction after the block ends.     If any exception occurs, it will rollback the transaction. If False, you have to manually commit or rollback the transaction. If you don't commit or rollback the transaction, it will be rolled back automatically.</p> <code>True</code> Example <pre><code>from sqlalchemy import create_engine\n\nfrom naked_sqla.om.session import SessionFactory\n\nengine = create_engine(\"sqlite+aiosqlite:///:memory:\", echo=False)\ndb = SessionFactory(engine)\n</code></pre> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def __init__(self, engine: Engine, *, auto_commit: bool = True):\n    self.engine = engine\n    self.auto_commit = auto_commit\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.SessionFactory.begin","title":"begin","text":"<pre><code>begin()\n</code></pre> <p>Create a new session, commits the transaction if auto_commit is True. Returns a context manager that yields a Session object.</p> <p>You can use this context manager with the <code>with</code> statement to access session.</p> Example <pre><code>from sqlalchemy import create_engine\nfrom naked_sqla.om.session import SessionFactory\n\nengine = create_engine(\"sqlite:///:memory:\")\ndb = SessionFactory(engine)\nwith db.begin() as session:\n    session.execute(\"SELECT * FROM users\")\n</code></pre> Source code in <code>naked_sqla/om/session.py</code> <pre><code>@contextmanager\ndef begin(self):\n    \"\"\"\n    Create a new session, commits the transaction if auto_commit is True.\n    Returns a context manager that yields a Session object.\n\n    You can use this context manager with the `with` statement to access session.\n\n    Example:\n        ```python\n        from sqlalchemy import create_engine\n        from naked_sqla.om.session import SessionFactory\n\n        engine = create_engine(\"sqlite:///:memory:\")\n        db = SessionFactory(engine)\n        with db.begin() as session:\n            session.execute(\"SELECT * FROM users\")\n        ```\n    \"\"\"\n\n    with self.engine.begin() as conn:\n        try:\n            yield Session(conn)\n            if self.auto_commit:\n                conn.commit()\n            else:\n                if conn.in_transaction():\n                    conn.rollback()\n\n        except Exception as err:\n            if self.auto_commit:\n                conn.rollback()\n            raise err\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.Session","title":"Session","text":"<pre><code>Session(conn: Connection)\n</code></pre> <p>Session is an object that represents a single transaction to the database. You can execute query statements and commit or rollback the transaction.</p> <p>Session is a simple wrapper around Connection object. The difference between Session and Connection is that Session would map     your query results to ORM objects.</p> Session is completely incompatible with sqlalchemy ORM Session. <p>Session is a simple wrapper around the Connection object.</p> <p>Please avoid using Session if you are depending on SQLAlchemy ORM. Any ORM feature in SQLAlchemy does not work with Session.</p> <p>These features could be:</p> <ul> <li>Tracking ORM objects: methods like <code>add</code>, <code>flush</code>, <code>expunge</code>, etc. Because our Session does not have any ORM object tracking. Which simplifies the implementation and makes it way faster.</li> </ul> <ul> <li>Relationship loading: methods like <code>load</code>, <code>lazyload</code>, etc. Because our Session does not make any implicit query to the database. You have to explicitly write the query. If you want to load related objects, you have to write a query for that and join the tables manually like you do in SQL.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>Connection</code> <p>The connection object that will be used for executing queries.</p> required Example <pre><code>from datetime import datetime\nfrom uuid import uuid4\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column\n\nfrom naked_sqla.om.session import SessionFactory\n\n\nclass BaseSQL(MappedAsDataclass, DeclarativeBase): ...\n\n\nclass Book(BaseSQL):\n    __tablename__ = \"Events\"\n    created_at: Mapped[datetime]\n    name: Mapped[str]\n    author_name: Mapped[str]\n    id: Mapped[str] = mapped_column(\n        primary_key=True, default_factory=lambda: str(uuid4())\n    )\n\n\nengine = create_engine(\"sqlite+aiosqlite:///:memory:\", echo=False)\ndb = SessionFactory(engine)\n\ndef get_session():\n    return db.begin()\n</code></pre> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def __init__(self, conn: Connection):\n    \"\"\"\n    Initialize a new session.\n    \"\"\"\n    self.conn = conn\n    self.state: Literal[\"open\", \"closed\"] = \"open\"\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.Session.commit","title":"commit","text":"<pre><code>commit()\n</code></pre> <p>Commit the transaction.</p> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def commit(self):\n    \"\"\"Commit the transaction.\"\"\"\n    if self.state == \"closed\":\n        raise Exception(\"Session is already closed\")\n    elif self.state == \"open\":\n        self.conn.commit()\n        self.state = \"closed\"\n    else:\n        assert_never(self.state)\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.Session.rollback","title":"rollback","text":"<pre><code>rollback()\n</code></pre> <p>Rollback the transaction.</p> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def rollback(self):\n    \"\"\"Rollback the transaction.\"\"\"\n    if self.state == \"closed\":\n        raise Exception(\"Session is already closed\")\n    elif self.state == \"open\":\n        self.conn.rollback()\n        self.state = \"closed\"\n    else:\n        assert_never(self.state)\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.Session.execute","title":"execute","text":"<pre><code>execute(statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = None, *, execution_options: Optional[_CoreKnownExecutionOptions] = None) -&gt; Result[Any]\n</code></pre> <p>Execute a query statement and return the result.</p> <p>After calling this method, you should call the <code>tuples</code> or <code>scalars</code> method to get the result.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The query statement to execute.</p> required <code>parameters</code> <code>Optional[_CoreAnyExecuteParams]</code> <p>The parameters to pass to the query.</p> <code>None</code> <code>execution_options</code> <code>Optional[_CoreKnownExecutionOptions]</code> <p>The execution options to pass to the query.</p> <code>None</code> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def execute(\n    self,\n    statement: Executable,\n    parameters: Optional[_CoreAnyExecuteParams] = None,\n    *,\n    execution_options: Optional[_CoreKnownExecutionOptions] = None,\n) -&gt; Result[Any]:\n    \"\"\"\n    Execute a query statement and return the result.\n\n    After calling this method, you should call the `tuples` or `scalars` method to get the result.\n\n    params:\n        statement:\n            The query statement to execute.\n        parameters:\n            The parameters to pass to the query.\n        execution_options:\n            The execution options to pass to the query.\n    \"\"\"\n    if (\n        isinstance(statement, dml.Insert)\n        or isinstance(statement, dml.Update)\n        or isinstance(statement, dml.Delete)\n    ):\n        return bulk_persistent.sync_orm_execute_statement(\n            self.conn,\n            statement,  # type: ignore\n            parameters=parameters,\n            execution_options=execution_options,\n        )\n\n    elif isinstance(statement, Executable):\n        return context.sync_orm_execute_statement(\n            self.conn,\n            statement,\n            parameters=parameters,\n            execution_options=execution_options,\n        )\n\n    else:\n        assert_never(statement)\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.Session.tuples","title":"tuples","text":"<pre><code>tuples(statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = None, *, execution_options: Optional[_CoreKnownExecutionOptions] = None) -&gt; TupleResult[Any]\n</code></pre> <p>Execute a query statement and return the result as tuples.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The query statement to execute.</p> required <code>parameters</code> <code>Optional[_CoreAnyExecuteParams]</code> <p>The parameters to pass to the query.</p> <code>None</code> <code>execution_options</code> <code>Optional[_CoreKnownExecutionOptions]</code> <p>The execution options to pass to the query.</p> <code>None</code> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def tuples(\n    self,\n    statement: Executable,\n    parameters: Optional[_CoreAnyExecuteParams] = None,\n    *,\n    execution_options: Optional[_CoreKnownExecutionOptions] = None,\n) -&gt; TupleResult[Any]:\n    \"\"\"\n    Execute a query statement and return the result as tuples.\n\n    params:\n        statement:\n            The query statement to execute.\n        parameters:\n            The parameters to pass to the query.\n        execution_options:\n            The execution options to pass to the query.\n    \"\"\"\n    result = (\n        self.execute(statement, parameters, execution_options=execution_options)\n    ).tuples()\n    return result\n</code></pre>"},{"location":"api/session/#naked_sqla.om.session.Session.scalars","title":"scalars","text":"<pre><code>scalars(statement: Executable, parameters: Optional[_CoreAnyExecuteParams] = None, *, execution_options: Optional[_CoreKnownExecutionOptions] = None) -&gt; ScalarResult[Any]\n</code></pre> <p>Execute a query statement and return the result as scalars.</p> <p>Scalar data types represent single values. They are the simplest forms of data types in programming. If you select two entities (e.x: two columns or two tables), it will return only first entity. Consider this as a shortcut when you are selecting only one entity, so you don't have to access to the first element of the tuple.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Executable</code> <p>The query statement to execute.</p> required <code>parameters</code> <code>Optional[_CoreAnyExecuteParams]</code> <p>The parameters to pass to the query.</p> <code>None</code> <code>execution_options</code> <code>Optional[_CoreKnownExecutionOptions]</code> <p>The execution options to pass to the query</p> <code>None</code> Source code in <code>naked_sqla/om/session.py</code> <pre><code>def scalars(\n    self,\n    statement: Executable,\n    parameters: Optional[_CoreAnyExecuteParams] = None,\n    *,\n    execution_options: Optional[_CoreKnownExecutionOptions] = None,\n) -&gt; ScalarResult[Any]:\n    \"\"\"\n    Execute a query statement and return the result as scalars.\n\n    Scalar data types represent single values. They are the simplest forms of data types in programming.\n    If you select two entities (e.x: two columns or two tables), it will return only first entity.\n    Consider this as a shortcut when you are selecting only one entity, so you don't have to access to the first element of the tuple.\n\n    params:\n        statement:\n            The query statement to execute.\n        parameters:\n            The parameters to pass to the query.\n        execution_options:\n            The execution options to pass to the query\n    \"\"\"\n\n    result = (\n        self.execute(statement, parameters, execution_options=execution_options)\n    ).scalars()\n    return result\n</code></pre>"},{"location":"api/view/","title":"Database View","text":"<p>A view in SQL is like a virtual table that you create using a SQL query. It doesn't store data itself but pulls it from one or more actual tables whenever you use it. Here\u2019s why you might use a view:</p> <ul> <li>Simplify Complex Queries: Instead of writing the same complicated joins or filters every time, you define them once in a view and just select from the view.</li> <li>Improve Security: You can restrict what data users see by only exposing certain columns or rows through the view, keeping sensitive information hidden.</li> <li>Enhance Maintainability: If the underlying table structure changes, you can update the view without having to change all the queries that use it.</li> <li>Consistency: Ensure that everyone is using the same logic to access data, reducing errors and inconsistencies.</li> </ul> <p>In short, views make your SQL work cleaner, safer, and easier to manage.</p>"},{"location":"api/view/#naked_sqla.view.CreateView","title":"CreateView","text":"<pre><code>CreateView(name: str, selectable: Select)\n</code></pre> <p>               Bases: <code>DDLElement</code></p> <p>A CREATE VIEW statement, usually useful when using in migrations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the view.</p> required <code>selectable</code> <code>Select</code> <p>The select statement to be used as the view.</p> required Example <pre><code>def main():\n    query = CreateView(ActiveBlog.__tablename__, active_view())\n    connection.execute(query) # this will create the view\n</code></pre> Source code in <code>naked_sqla/view.py</code> <pre><code>def __init__(self, name: str, selectable: sa.Select):\n    self.name = name\n    self.selectable = selectable\n</code></pre>"},{"location":"api/view/#naked_sqla.view.DropView","title":"DropView","text":"<pre><code>DropView(name, cascade=False, if_exists=False)\n</code></pre> <p>               Bases: <code>DDLElement</code></p> <p>A DROP VIEW statement, usually useful when using in migrations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the view.</p> required <code>cascade</code> <p>Whether to drop the view with cascade or not.</p> <code>False</code> <code>if_exists</code> <p>Whether to drop the view if it exists or not.</p> <code>False</code> Example <pre><code>def main():\n    query = DropView(ViewTable.__tablename__)\n    connection.execute(query) # this will drop the view table\n</code></pre> Source code in <code>naked_sqla/view.py</code> <pre><code>def __init__(self, name, cascade=False, if_exists=False):\n    self.name = name\n    self.cascade = cascade\n    self.if_exists = if_exists\n</code></pre>"},{"location":"api/view/#naked_sqla.view.init_view_in_base","title":"init_view_in_base","text":"<pre><code>init_view_in_base(cls: Type[DeclarativeBase])\n</code></pre> <p>Calling this function is required to allow a declarative base to have views as tables. Look at the example below to see how to use it.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[DeclarativeBase]</code> <p>The declarative base class to be initialized.</p> required Example <pre><code>from sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\n\nclass BaseSQL(MappedAsDataclass, DeclarativeBase):\n    def __init_subclass__(\n        cls,\n        *args,\n        **kw,\n    ) -&gt; None:\n        init_view_in_base(cls)\n        super().__init_subclass__(*args, **kw)\n</code></pre> Source code in <code>naked_sqla/view.py</code> <pre><code>def init_view_in_base(cls: Type[DeclarativeBase]):\n    \"\"\"\n    Calling this function is required to allow a declarative base to have views as tables.\n    Look at the example below to see how to use it.\n\n    Params:\n        cls: The declarative base class to be initialized.\n\n    Example:\n        ```python hl_lines=\"9-10\"\n\n        from sqlalchemy.orm import DeclarativeBase, MappedAsDataclass\n\n        class BaseSQL(MappedAsDataclass, DeclarativeBase):\n            def __init_subclass__(\n                cls,\n                *args,\n                **kw,\n            ) -&gt; None:\n                init_view_in_base(cls)\n                super().__init_subclass__(*args, **kw)\n        ```\n\n\n    \"\"\"\n    if hasattr(cls, \"__table__\"):\n        table_clause = cls.__table__  # type: ignore\n        if isinstance(table_clause, _View):\n            for k in cls.__annotations__:\n                # a table initiated with __table__ cannot have mapped_column and Mapped\n                # https://github.com/sqlalchemy/sqlalchemy/commit/3b7ffd2f9745e6038bbb7209635d3407fe8ff5ec\n                annotation = cls.__annotations__[k]\n                annotation = typing.get_args(annotation)[0]  # remove Mapped\n                cls.__annotations__[k] = annotation\n</code></pre>"},{"location":"api/view/#naked_sqla.view.view_table","title":"view_table","text":"<pre><code>view_table(name, metadata, selectable, *, cascade=True)\n</code></pre> <p>Create a view table.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the view.</p> required <code>metadata</code> <p>The metadata object to bind the view to.</p> required <code>selectable</code> <p>The select statement to be used as the view.</p> required <code>cascade</code> <p>Whether to drop the view with cascade or not.</p> <code>True</code> Example <pre><code>from datetime import datetime\nfrom uuid import uuid4\n\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column\n\nfrom naked_sqla.view import init_view_in_base, view_table\n\n\nclass BaseSQL(MappedAsDataclass, DeclarativeBase):\n    def __init_subclass__(\n        cls,\n        *args,\n        **kw,\n    ) -&gt; None:\n        init_view_in_base(cls)\n        super().__init_subclass__(*args, **kw)\n\n\nclass Event(BaseSQL):\n    __tablename__ = \"Events\"\n    event: Mapped[str] = mapped_column(sa.String())\n    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True))\n    id: Mapped[str] = mapped_column(\n        primary_key=True, default_factory=lambda: str(uuid4())\n    )\n    author_id: Mapped[str] = mapped_column(\n        primary_key=True, default_factory=lambda: str(uuid4())\n    )\n\n\ndef event_period_view_query():\n    event_transitions = sa.select(\n        Event.author_id,\n        Event.event,\n        Event.created_at,\n        sa.func.lead(Event.created_at)\n        .over(\n            partition_by=Event.author_id,\n            order_by=Event.created_at,\n        )\n        .label(\"next_created_at\"),\n    ).subquery()\n\n    event_periods = sa.select(\n        event_transitions.c.author_id,\n        event_transitions.c.event,\n        event_transitions.c.created_at.label(\"start_datetime\"),\n        sa.func.coalesce(event_transitions.c.next_created_at, sa.func.now()).label(\n            \"end_datetime\"\n        ),\n    ).select_from(event_transitions)\n    return event_periods\n\n\nclass EventPeriod(BaseSQL):\n    __tablename__ = \"EventPeriods\"\n    __table__ = view_table(__tablename__, BaseSQL.metadata, event_period_view_query())\n\n    author_id: Mapped[str]\n    event: Mapped[str]\n    start_datetime: Mapped[datetime]\n    end_datetime: Mapped[datetime]\n</code></pre> Source code in <code>naked_sqla/view.py</code> <pre><code>def view_table(name, metadata, selectable, *, cascade=True):\n    \"\"\"Create a view table.\n\n    Params:\n        name: The name of the view.\n        metadata: The metadata object to bind the view to.\n        selectable: The select statement to be used as the view.\n        cascade: Whether to drop the view with cascade or not.\n\n    Example:\n        ```python\n        from datetime import datetime\n        from uuid import uuid4\n\n        import sqlalchemy as sa\n        from sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column\n\n        from naked_sqla.view import init_view_in_base, view_table\n\n\n        class BaseSQL(MappedAsDataclass, DeclarativeBase):\n            def __init_subclass__(\n                cls,\n                *args,\n                **kw,\n            ) -&gt; None:\n                init_view_in_base(cls)\n                super().__init_subclass__(*args, **kw)\n\n\n        class Event(BaseSQL):\n            __tablename__ = \"Events\"\n            event: Mapped[str] = mapped_column(sa.String())\n            created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True))\n            id: Mapped[str] = mapped_column(\n                primary_key=True, default_factory=lambda: str(uuid4())\n            )\n            author_id: Mapped[str] = mapped_column(\n                primary_key=True, default_factory=lambda: str(uuid4())\n            )\n\n\n        def event_period_view_query():\n            event_transitions = sa.select(\n                Event.author_id,\n                Event.event,\n                Event.created_at,\n                sa.func.lead(Event.created_at)\n                .over(\n                    partition_by=Event.author_id,\n                    order_by=Event.created_at,\n                )\n                .label(\"next_created_at\"),\n            ).subquery()\n\n            event_periods = sa.select(\n                event_transitions.c.author_id,\n                event_transitions.c.event,\n                event_transitions.c.created_at.label(\"start_datetime\"),\n                sa.func.coalesce(event_transitions.c.next_created_at, sa.func.now()).label(\n                    \"end_datetime\"\n                ),\n            ).select_from(event_transitions)\n            return event_periods\n\n\n        class EventPeriod(BaseSQL):\n            __tablename__ = \"EventPeriods\"\n            __table__ = view_table(__tablename__, BaseSQL.metadata, event_period_view_query())\n\n            author_id: Mapped[str]\n            event: Mapped[str]\n            start_datetime: Mapped[datetime]\n            end_datetime: Mapped[datetime]\n        ```\n\n\n\n    \"\"\"\n\n    t = _View.from_name(name)\n    t._columns._populate_separate_keys(\n        col._make_proxy(t) for col in selectable.selected_columns\n    )\n    sa.event.listen(\n        metadata,\n        \"after_create\",\n        CreateView(name, selectable).execute_if(callable_=_view_doesnt_exist),  # type: ignore\n    )\n    sa.event.listen(\n        metadata,\n        \"before_drop\",\n        DropView(name, cascade=cascade).execute_if(callable_=_view_exists),  # type: ignore\n    )\n    return t\n</code></pre>"},{"location":"get-started/why/","title":"Why Naked SQLAlchemy?","text":"<p>TLDR; Naked SQLAlchemy is a thin layer on top of SQLAlchemy Core that makes it easier to work with databases in Python. It simplifies the process of executing queries and mapping results to data classes, without the complexity of an ORM. It's faster, more efficient, and easier to understand and eaiser to maintain than traditional ORMs.</p> <p>Naked SQLAlchemy also offers some extra features that are not available in SQLAlchemy Core, and planning to add more features in the future, current features are:</p> <ol> <li>Dataclass Mapping: Automatically map query results to data classes.</li> <li>Stateless Session Management: Manage database connections and transactions.</li> <li>Database Views: Define views just like tables!</li> </ol>"},{"location":"get-started/why/#sqlalchemy","title":"SQLAlchemy","text":"<p>SQLAlchemy is a Python library for working with databases. It has two main components:</p> <ol> <li>Core</li> <li>ORM</li> </ol>"},{"location":"get-started/why/#core","title":"Core","text":"<p>A SQL toolkit that allows you to write database queries using Python code. It provides a way to construct SQL expressions and execute them without writing raw SQL.</p> <p>Here are some highlights of the Core:</p> <ul> <li> <p>DML (Data Manipulation Language) Statements:</p> <ul> <li>Insert: Add new records to tables.</li> <li>Update: Modify existing records.</li> <li>Delete: Remove records from tables.</li> <li>Select: Retrieve data from tables.</li> </ul> </li> </ul> <ul> <li> <p>SQL Expression Language:</p> <ul> <li>Define tables and columns using Python classes.</li> <li>Build complex SQL queries using Python expressions.</li> </ul> </li> </ul> <ul> <li> <p>Connection Pooling:</p> <ul> <li>Efficiently manage database connections.</li> <li>Support for transactions and concurrency.</li> </ul> </li> </ul> <ul> <li> <p>Databse Connection:</p> <ul> <li>Connect to a wide variety of databases (SQLite, MySQL, PostgreSQL, etc.).</li> <li>Use a consistent API regardless of the database backend.</li> <li>Support for database-specific features.</li> </ul> </li> </ul>"},{"location":"get-started/why/#orm","title":"ORM","text":"<p>The Object-Relational Mapper (ORM) is a layer on top of the Core that lets you map database tables to Python classes. This means you can work with your data as Python objects rather than dealing directly with SQL queries.</p> <p>Features of the ORM include:</p> <ul> <li> <p>Object Mapping:</p> <ul> <li>Use Python classes to define database models.</li> </ul> </li> </ul> <ul> <li> <p>Relationship Management:</p> <ul> <li>Define relationships between models (one-to-many, many-to-many).</li> <li>Automatically handle joins and foreign keys.</li> </ul> </li> </ul> <ul> <li> <p>Session Management:</p> <ul> <li>Interact with the database through a session.</li> <li>Manage transactions and track changes to objects.</li> </ul> </li> </ul> <ul> <li> <p>Dirty Tracking:</p> <ul> <li>Detect changes to objects and update the database accordingly.<ul> <li>So updating a python ORM object in memory will automatically update the database when the session is committed.</li> <li>Keeping the database in sync with the python objects.</li> </ul> </li> </ul> </li> </ul>"},{"location":"get-started/why/#orms-are-conceptually-wrong","title":"ORMs are conceptually wrong ...","text":"<p>As you have read, there are many features in SQLAlchemy ORM/today's ORM. They are no longer just a simple object mapper, but a full-fledged data manipulation tool, which is conceptually wrong. but why?</p> <p>There are many pitfall in ORMs, they are hard to learn, very complex, and they are not even close to being efficient and fast!</p> <p>Read about some of the pitfalls of ORMs:</p> The pitfall of Dirty Tracking <p>Imagine this scenario:     1. Query user id 1 from the database.     2. Mutate the user first name from \"John\" to \"Jane\".     3. Query user id 1 again from the database.     4. Mutate the last name from \"Doe\" to \"Smith\".     5. Commit the transaction.</p> <p>What do you think happens? Well, SQLAlchemy ORM will update both first name and last name as expected, which looks great at first glance. But think about how it would do that?</p> <ol> <li> <p>When you query a row first time, SQLAlchemy construct an identitiy key for that row. Identity key is a unique key that identifies a row in the database. By design, it always pick \"primary key\" as the identity key, which makes sense.  Then keep the object in the memory, and track all the changes you make to that object, and mapped it to the identity key.</p> </li> <li> <p>Then next time you query the same table from database again, it calculate identity key, and check if the object is already in the memory. Given our scenario, the object exists in memory. So it makes a diff between the object in memory and the object from the database, and apply the diff to the object in memory. After that, it always only keep one version of the object in memory and disregard the other version of the object that came from database.</p> </li> </ol> <p>Check this example:</p> <pre><code>obj1 = sa.select(User).where(User.id == 1).scalar().one()\nobj1.first_name = \"Jane\"\n\nobj2 = sa.select(User).where(User.id == 1).scalar().one()\nobj2.last_name = \"Smith\"\n\nobj2.first_name # Jane\n</code></pre> <p>why obj2 first name is \"Jane\"? Because the object in memory is the same object that came from the first query. So the changes you made to the object in memory is still there. This is the dirty tracking feature of SQLAlchemy ORM. It's implictly mutating other objects in memory, so in fact obj1 and obj2 are the same object, and have same memory address.</p> <p>Why is this bad idea in my opinion?</p> <ol> <li> <p>Explicit is better than implicit. It's hard to understand what's going on in the background.</p> </li> <li> <p>What if you can't uniquly identify a row from database? The assumption to always fallback on primary key and table always have primary key is wrong, a view does not have a primary key, and a table might not have a primary key as well. So what if you can't uniquely identify a row from database? Well, you can't use ORM in that case. That is why View could be easily supported in Naked SQLAlchemy, but not in SQLAlchemy ORM.</p> </li> <li> <p>What if something goes wrong in this process? Good luck with that! It's a nightmare to debug such issues.     I already faced such issues. The side effect is that if algorithm fail to understand the diff, the object you had in memory     is not same as the object returned by database. I had a case where I was updating a row, setting a value to 2, and fetching the row from database again, when I got the row back, the value was still 1 on my memory! but of course this only happens with SQLAlchemy ORM, not with Core. because Core doesn't have such feature and simply create a python object for each row fetched from database.</p> </li> </ol> <p>This is the code snippet that caused this issue:</p> <pre><code># --------------------------------------\n# it seems SQLAlchemy tries to figure out what changes happened to database, and try to apply it to the tracked objects from Sessoin\n# if update query is too complicated, it just fail\n# then worst thing happens, it shadow a completely different object as result of database\n# but if you run the query with connection(CORE), it works and return corrected result.\n# --------------------------------------\n\nfrom contextlib import asynccontextmanager\nfrom dataclasses import asdict\nfrom datetime import UTC, datetime, timedelta\nfrom uuid import uuid4\n\nimport pytest\nimport sqlalchemy as sa\nfrom sqlalchemy.ext.asyncio import AsyncSession as SmartAsyncSession\nfrom sqlalchemy.ext.asyncio import async_sessionmaker, create_async_engine\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, MappedAsDataclass, mapped_column\n\nfrom naked_sqla.om.asession import AsyncSession, AsyncSessionFactory\n\nclass BaseSQL(MappedAsDataclass, DeclarativeBase): ...\n\nclass Event(BaseSQL):\n**tablename** = \"Events\"\nevent: Mapped[str] = mapped_column(sa.String())\ncreated_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True))\nid: Mapped[str] = mapped_column(\nprimary_key=True, default_factory=lambda: str(uuid4())\n)\nauthor_id: Mapped[str] = mapped_column(\nprimary_key=True, default_factory=lambda: str(uuid4())\n)\n\n@asynccontextmanager\nasync def init_naked_db():\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\", echo=False)\ndb = AsyncSessionFactory(engine)\nasync with engine.begin() as conn:\nawait conn.run_sync(BaseSQL.metadata.create_all)\nyield db\n\n@asynccontextmanager\nasync def init_sqlachemy_db():\nengine = create_async_engine(\"sqlite+aiosqlite:///:memory:\", echo=False)\ndb = async_sessionmaker(engine, expire_on_commit=False, autobegin=False)\nasync with engine.begin() as conn:\nawait conn.run_sync(BaseSQL.metadata.create_all)\nyield db\n\nasync def complicated_update_scenario(session: AsyncSession | SmartAsyncSession):\n\"\"\"\nA scenario where we need to update a row based on the next row's value.\nThe updated row is the one that has the event value of \"2\".\n\"\"\"\nnow = datetime.now(UTC)\nauthor_id = str(uuid4())\nobjs = [\nEvent(author_id=author_id, event=\"1\", created_at=now - timedelta(days=4)),\nEvent(author_id=author_id, event=\"2\", created_at=now - timedelta(days=3)),\n]\n\n    inserted_objs = (\n        await session.execute(\n            sa.insert(Event).returning(Event), [asdict(obj) for obj in objs]\n        )\n    ).all()\n    print(inserted_objs)\n\n    event_lead = sa.select(\n        Event.id,\n        sa.func.lead(Event.event)\n        .over(\n            partition_by=Event.author_id,\n            order_by=Event.created_at,\n        )\n        .label(\"next_event\"),\n    ).subquery()\n    event_query = (\n        sa.select(event_lead.c.id)\n        .select_from(event_lead)\n        .where(event_lead.c.next_event == \"2\")\n    )\n\n    query = (\n        sa.update(Event)\n        .where(Event.id.in_(event_query))\n        .values(event=\"2\")\n        .returning(Event)\n    )\n\n    result = (await session.execute(query)).scalars().first()\n    assert result is not None\n    return result\n\n@pytest.mark.asyncio\nasync def test_complicated_update_map_correctly_in_naked_sqla():\nasync with init_naked_db() as db:\nasync with db.begin() as session:\nresult = await complicated_update_scenario(session)\nassert result.event == \"2\"\n\n@pytest.mark.asyncio\nasync def test_complicated_update_map_incorrectly_in_sqlalchemy():\nasync with init_sqlachemy_db() as db:\nasync with db.begin() as session:\nresult = await complicated_update_scenario(session)\nassert result.event == \"1\"\n</code></pre> The pitfall of Relationship Management <p>The pitfall of relationship management is N+1 query problem. It's a common problem in ORMs, where you fetch a row from a table, and then fetch related rows from another table, and then fetch related rows from another table, and so on. This results in a large number of queries being executed, which can be slow and inefficient.</p>  The pitfall of Session Management <p>The pitfall of session is that if your transaction is rollbacked, the session will automatically expire your object. That means, althought you have the object typed in your code, but if you try to access the attribute, it fails. This of course make sense if you think about it, because the object is not in the database anymore, so it should not be in the memory as well. But it's a pitfall if you are not aware of it. Session is a very stateful and comlpex object in SQLAlchemy.</p> <p>And to be honest, I don't understand the win. What benfit would ORM have for you?</p> <ol> <li>Not writing an explicit join so it figures out by itself implicitly?</li> <li>Reusing a old out-of-date object in memory instead of fetching the new one from database?</li> <li>Not updating the database when you update the object in memory?</li> </ol> <p>Compare these wins, to negative sides of ORM; what if we use SQL very explicitly, and write the joins explicitly, and fetch the new object from database every time we need it, and update the database explicitly? Well, that's basically using Core!</p> <ol> <li> <p>Universal Understanding: SQL is a well-established language that most developers are familiar with. By using SQL directly, you tap into a common knowledge base, making it easier for team members to read and understand the code.</p> </li> <li> <p>Shallow Learning Curve: Learning an ORM often requires understanding a new set of abstractions and query syntax. Sticking with SQL or SQLAlchemy Core minimizes the learning curve, allowing developers to be productive quickly.</p> </li> <li> <p>Code Readability: SQL queries written using SQLAlchemy Core are more transparent and closer to actual SQL. This makes the code easier to read and maintain, as opposed to deciphering ORM-specific methods and functions.</p> </li> <li> <p>Avoiding Over-Abstraction: SQL is already an abstraction over the way data is stored and retrieved. Introducing an ORM adds another layer of abstraction, which can sometimes obscure what's happening under the hood and lead to less efficient code.</p> </li> </ol> <p>but there's one small issue with using Core, it does not map the result of query to a dataclass. So imagine you write a query such as <code>sa.select(User)</code>, what happens is that it return you a tuple of rows, where each row is a tuple of columns. So you need to manually map the result to a dataclass.</p> <p>And that's what this library is for! Naked SQLAlchemy is a library that provides a thin layer on top of SQLAlchemy Core to make it easier to work with databases in Python. It simplifies the process of executing queries, and mapping results to data classes. The new \"ORM\" or Object mapper I call it I wrote, the first working version was 500 lines of code only, which is about ~30 times less than SQLAlchemy code, and significantly faster and more efficient, because it's doing only what it should do, and nothing more.</p> <p>The key to making programs fast is to make them do practically nothing.</p> <p>-- Mike Haertel, Author of GNU grep</p>"}]}