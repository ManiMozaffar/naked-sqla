from __future__ import annotations

import operator
from typing import TYPE_CHECKING, Any, TypeVar, Union

from sqlalchemy import util
from sqlalchemy.engine.cursor import CursorResult
from sqlalchemy.engine.result import ChunkedIteratorResult, Result, SimpleResultMetaData
from sqlalchemy.orm.context import (
    _BundleEntity,
    _ColumnEntity,
    _MapperEntity,
    _QueryEntity,
)
from sqlalchemy.util import EMPTY_DICT
from typing_extensions import assert_never

from naked_sqla.exception import BaseNakedSQLAException

if TYPE_CHECKING:
    from naked_sqla.om.context import QueryContext

    def instance_dict(instance: object) -> dict[str, Any]: ...

else:
    instance_dict = operator.attrgetter("__dict__")


class UnknownEntity(BaseNakedSQLAException):
    def __init__(self, entity: _QueryEntity):
        super().__init__(
            f"""Unknown entity: {entity!r}.
This means you had an entity in your query that could not be known by the OM.

Might be caused by using an external library beside sqlalchemy or using a custom entity.
If you only selected column, object or bundle, please report this issue in github.
https://github.com/ManiMozaffar/naked-sqla
            """
        )


_T = TypeVar("_T", bound=Any)
_O = TypeVar("_O", bound=object)


def instances(cursor: CursorResult[Any], context: QueryContext) -> Result[Any]:
    """Return a :class:`.Result` given an ORM query context.

    :param cursor: a :class:`.CursorResult`, generated by a statement
     which came from :class:`.ORMCompileState`

    :param context: a :class:`.QueryContext` object

    :return: a :class:`.Result` object representing ORM results

    .. versionchanged:: 1.4 The instances() function now uses
       :class:`.Result` objects and has an all new interface.

    """

    compile_state = context.compile_state
    filtered = compile_state._has_mapper_entities
    single_entity = (
        not context.load_options._only_return_tuples
        and len(compile_state._entities) == 1
        and compile_state._entities[0].supports_single_entity
    )

    try:
        (process, labels, extra) = list(
            zip(
                *[
                    row_processor(query_entity, context, cursor)
                    for query_entity in context.compile_state._entities
                ]
            )
        )

    except Exception:
        with util.safe_reraise():
            cursor.close()

    row_metadata = SimpleResultMetaData(labels, extra, _unique_filters=None)  #  type: ignore

    def chunks(size):  # type: ignore
        while True:
            yield_per = size

            context.partials = {}  # type: ignore

            if yield_per:
                fetch = cursor.fetchmany(yield_per)

                if not fetch:
                    break
            else:
                fetch = cursor._raw_all_rows()

            if single_entity:
                proc = process[0]  # type: ignore
                rows = [proc(row) for row in fetch]
            else:
                rows = [tuple([proc(row) for proc in process]) for row in fetch]  # type: ignore

            yield rows

            if not yield_per:
                break

    # if context.execution_options.get("prebuffer_rows", False):
    #     # this is a bit of a hack at the moment.
    #     # I would rather have some option in the result to pre-buffer
    #     # internally.
    #     _prebuffered = list(chunks(None))

    #     def chunks(size):
    #         return iter(_prebuffered)

    result = ChunkedIteratorResult(
        row_metadata,
        chunks,
        source_supports_scalars=single_entity,
        raw=cursor,
        dynamic_yield_per=cursor.context._is_server_side,
    )

    # filtered and single_entity are used to indicate to legacy Query that the
    # query has ORM entities, so legacy deduping and scalars should be called
    # on the result.
    result._attributes = result._attributes.union(
        dict(filtered=filtered, is_single_entity=single_entity)
    )

    if context.yield_per:
        result.yield_per(context.yield_per)

    return result


def row_processor(
    entity: Union[_QueryEntity, _BundleEntity, _ColumnEntity, _MapperEntity],
    context: QueryContext,
    cursor: CursorResult[Any],
):
    if isinstance(entity, _BundleEntity):
        return entity.row_processor(context, cursor)
    elif isinstance(entity, _MapperEntity):
        return mapper_entity_row_processor(entity, context, cursor)
    elif isinstance(entity, _ColumnEntity):
        return entity.row_processor(context, cursor)
    elif isinstance(entity, _QueryEntity):
        raise UnknownEntity(entity)
    else:
        assert_never(entity)


def mapper_entity_row_processor(
    entity: _MapperEntity, context: QueryContext, result: CursorResult[Any]
):
    compile_state = context.compile_state
    adapter = entity._get_entity_clauses(compile_state)
    _instance = _instance_processor(
        entity,
        entity.mapper,
        context,
        result,
        entity.path,
        adapter,
    )

    return _instance, entity._label_name, entity._extra_entities


def _instance_processor(query_entity, mapper, context, result, path, adapter):
    """Produce a mapper level row processor callable
    which processes rows into mapped instances."""

    compile_state = context.compile_state
    getter_key = ("getters", mapper)
    getters = path.get(compile_state.attributes, getter_key, None)

    if getters is None:
        props = mapper._prop_set

        quick_populators = path.get(context.attributes, "memoized_setups", EMPTY_DICT)

        cached_populators = {"quick": []}
        getters = {"cached_populators": cached_populators, "primary_key_getter": None}
        for prop in props:
            if prop in quick_populators:
                # this is an inlined path just for column-based attributes.
                col = quick_populators[prop]
                getter = result._getter(col, False)
                if getter:
                    cached_populators["quick"].append((prop.key, getter))
                else:
                    # fall back to the ColumnProperty itself, which
                    # will iterate through all of its columns
                    # to see if one fits
                    prop.create_row_processor(
                        context,
                        query_entity,
                        path,
                        mapper,
                        result,
                        adapter,
                        cached_populators,
                    )

        path.set(compile_state.attributes, getter_key, getters)

    cached_populators = getters["cached_populators"]
    populators = {key: list(value) for key, value in cached_populators.items()}

    def _instance(row):
        instance = mapper.class_manager.new_instance()
        dict_ = instance_dict(instance)

        for key, getter in populators["quick"]:
            dict_[key] = getter(row)
        return instance

    return _instance
